name: Smoke Test

on:
  workflow_dispatch:
    inputs:
      app_image_tag:
        description: 'App image tag to deploy'
        required: false
        default: 'latest'
      model_image_tag:
        description: 'Model service image tag to deploy'
        required: false
        default: 'latest'

jobs:
  smoke-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Minikube
        run: |
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube

      - name: Start Minikube
        run: |
          minikube start --driver=docker --cpus=2 --memory=4096

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Configure Docker to use Minikube registry
        run: |
          eval $(minikube docker-env)

      - name: Create GHCR pull secret
        run: |
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --docker-email=ci@github.com || true

      - name: Deploy Helm chart
        run: |
          helm dependency update deployment/
          helm upgrade --install smoke-test deployment/ \
            --set image.app.tag=${{ inputs.app_image_tag }} \
            --set image.model.tag=${{ inputs.model_image_tag }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --set services.type=NodePort \
            --set ingress.enabled=false \
            --set istio.enabled=false \
            --set istio.canary.enabled=false \
            --set prometheus.enabled=false \
            --set kube-prometheus-stack.enabled=false \
            --set autoscaling.enabled=false \
            --wait \
            --timeout=5m

      - name: Wait for pods to be ready
        run: |
          echo "Waiting for app deployment..."
          kubectl rollout status deployment -l app.kubernetes.io/instance=smoke-test --timeout=300s || true
          
          echo "Listing all pods..."
          kubectl get pods -o wide
          
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=smoke-test --timeout=300s || true

      - name: Expose services and run health checks
        run: |
          echo "Getting service info..."
          kubectl get svc
          
          # Get the app service URL via minikube
          APP_URL=$(minikube service app --url 2>/dev/null || echo "")
          
          if [ -z "$APP_URL" ]; then
            echo "Could not get app URL via minikube service, using port-forward..."
            kubectl port-forward svc/app 8080:80 &
            PF_PID=$!
            sleep 5
            APP_URL="http://localhost:8080"
          fi
          
          echo "App URL: $APP_URL"
          
          # Test splash page
          echo "Testing splash page..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL/" || echo "000")
          echo "Splash page HTTP status: $HTTP_CODE"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "Splash page check PASSED"
          else
            echo "Splash page check FAILED (expected 200, got $HTTP_CODE)"
            SPLASH_FAILED=1
          fi
          
          # Test model service API
          MODEL_URL=$(minikube service model-service --url 2>/dev/null || echo "")
          
          if [ -z "$MODEL_URL" ]; then
            echo "Could not get model-service URL via minikube service, using port-forward..."
            kubectl port-forward svc/model-service 8081:8081 &
            sleep 5
            MODEL_URL="http://localhost:8081"
          fi
          
          echo "Model service URL: $MODEL_URL"
          
          echo "Testing model service health/ping..."
          MODEL_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$MODEL_URL/" || echo "000")
          echo "Model service HTTP status: $MODEL_CODE"
          
          if [ "$MODEL_CODE" = "200" ] || [ "$MODEL_CODE" = "404" ]; then
            echo "Model service check PASSED (service is responding)"
          else
            echo "Model service check FAILED (expected 200 or 404, got $MODEL_CODE)"
            MODEL_FAILED=1
          fi
          
          # Kill port-forward if started
          if [ -n "$PF_PID" ]; then
            kill $PF_PID 2>/dev/null || true
          fi
          
          # Final result
          if [ "$SPLASH_FAILED" = "1" ] || [ "$MODEL_FAILED" = "1" ]; then
            echo "SMOKE TEST FAILED"
            exit 1
          fi
          
          echo "SMOKE TEST PASSED"

      - name: Collect diagnostics on failure
        if: failure()
        run: |
          echo "=== Pod Status ==="
          kubectl get pods -o wide
          
          echo ""
          echo "=== Pod Descriptions ==="
          kubectl describe pods
          
          echo ""
          echo "=== App Logs ==="
          kubectl logs -l app.kubernetes.io/name=app-deployment --tail=100 || true
          
          echo ""
          echo "=== Model Service Logs ==="
          kubectl logs -l app.kubernetes.io/name=model-deployment --tail=100 || true
          
          echo ""
          echo "=== Events ==="
          kubectl get events --sort-by='.lastTimestamp'

      - name: Upload diagnostics artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-diagnostics
          path: |
            /tmp/diagnostics/
          retention-days: 7
        continue-on-error: true

      - name: Cleanup
        if: always()
        run: |
          minikube delete || true
